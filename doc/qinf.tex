\documentclass[leqno,10pt]{article}
\usepackage{boxedminipage}

% when these lines were placed too far below here,
% makeindex mysteriously produced no entries
\usepackage{makeidx} 
\makeindex

\usepackage{html}

% Make boxed minipage  wider for html version
\html{ \newcommand{\bbm}{\vspace{5pt}\par\noindent\begin{boxedminipage}{2.0\linewidth}} }
\latex{ \newcommand{\bbm}{\vspace{5pt}\par\noindent\begin{boxedminipage}{1.05\linewidth}} }

% links to the maxima manual. this also gives the top directory
%\def\maxdocdir{/usr/share/doc/maxima-doc/html/}
%\def\maxdocdir{../maxima_html/}
\def\maxdocdir{http://maxima.sourceforge.net/docs/manual/en/}
\newcommand{\maxlink}[1]{{\maxdocdir}#1}
%\newcommand{\maxman}[2]{{\htmladdnormallink{#1}{{\maxdocdir}#2}}  % link to page in manual
\html{\newcommand{\maxman}[2]{\hlink{#1}{\maxlink{#2}}}}
\latex{\newcommand{\maxman}[2]{#1}}

\newcommand{\hlink}[2]{\htmladdnormallink{#1}{#2}}

%\def\man_abasep{maxima_29.html\#IDX1037}
\input{man_index.tex}
\input{man_contents.tex}

\usepackage{graphicx}
\usepackage{hyperref}
%\usepackage{pdftex} % not there
%\usepackage{mathpazo}
%% following is added by imaxima output
\usepackage{verbatim}
\usepackage[cmbase]{flexisym}
\usepackage{bbold}

%bbold above conflicts with amssymb \usepackage{amssymb}
\usepackage{breqn}
\setkeys{breqn}{compact}

\def\supertiny{ \font\supertinyfont = cmr6 at 4pt \relax
\supertinyfont}


%\usepackage{amssymb} this breaks bbold numeral
%\usepackage{amsmath}

\newcommand{\ebm}{\end{boxedminipage}\vspace{5pt}\par\noindent}
\setlength{\fboxrule}{0.1pt} 
\setlength{\fboxsep}{10pt}


\setlength{\textwidth}{180mm}
\setlength{\oddsidemargin}{15mm}
\addtolength{\oddsidemargin}{-1in}
\setlength{\evensidemargin}{15mm}
\addtolength{\evensidemargin}{-1in}

\newcommand{\ifrac}[2]{\frac{#1}{#2}}
\newcommand{\ifracd}[2]{\frac{#1}{#2}}
\newcommand{\ifracn}[2]{\frac{#1}{#2}}
\newcommand{\isubscript}[2]{{#1}_{#2}}
\newcommand{\iexpt}[2]{{#1}^{#2}}
\newcommand{\isqrt}[1]{\sqrt{#1}}
%% end lines added by imaxima output

\newcommand{\ket}[1]{{\lvert#1 \rangle}}
\newcommand{\bra}[1]{{\langle#1 \rvert}}
\newcommand{\func}[2]{{\bf #1}($#2$)}
\newcommand{\marray}[2]{{\bf #1}[$#2$]}
\newcommand{\fs}[1]{{\bf #1}}

% refer to a function and add an index entry
\newcommand{\ifs}[1]{{{\bf #1}}\index{#1@{\bf #1}}} % bold index entry plus bold in text
\newcommand{\ient}[1]{{#1}\index{#1}} % index entry plus text
\newcommand{\ibd}[1]{\index{#1@{\bf #1}}} % bold index entry
\newcommand{\iit}[1]{\index{#1@{\it #1}}} % italic index entry
% package or software proper name, with an index entry
\newcommand{\ipname}[1]{{\it #1}\index{#1@{\it #1}}}
\newcommand{\pname}[1]{{\it #1}} % software name 
\newcommand{\imarray}[2]{\marray{#1}{#2}\index{#1@{\marray{#1}{#2}}}} % \marray with index entry
\newcommand{\ifunc}[2]{\func{#1}{#2}\index{#1@\func{#1}{#2}}} % \func with index entry
\newcommand{\qinf}{ {\it qinf } } % the name of this package
\newcommand{\qinfp}{{\it qinf}} % use at end of sentece for period

\newcommand{\farg}[1]{{\it #1}} % an argument

\newcommand{\maximalink}{\htmladdnormallink{ \pname{Maxima} }{http://maxima.sourceforge.net/}}

% probably not used
\newcommand{\maxcom}{\textsuperscript{$\dagger$}}

\begin{document}


\title{User's Manual for \qinf Quantum Information and Entanglement Package
 v. 0.08 For The \pname{Maxima} Computer
  Algebra System}

\author{G. John Lapeyre, Jr.}

\maketitle



\begin{verbatim}
         Copyright (c)  2008  Gerald John Lapeyre Jr.
         Permission is granted to copy, distribute and/or modify this document
         under the terms of the GNU Free Documentation License, Version 1.2
         or any later version published by the Free Software Foundation;
         with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
         A copy of the license is included in the distribution of the source
         code of the software accompanying this manual in the file fdl.txt.
\end{verbatim}

\tableofcontents

\htmlrule
\section{Introduction}

This quantum information package for the 
\maximalink computer
algebra system allows the manipulation of instances of
objects--- operators, vectors, tensors, {\it etc.}  that
appear in quantum information theory.  More precisely these
objects are typically represented in this package in a
particular basis as row and column vectors and matrices,
whose entries may be explicit numbers (of various classes)
or algebraic expressions. This software occupies a niche
distinct from high performance numerical linear algebra
software as well as software such as the \maximalink tensor
packages that manipulate abstract mathematical objects.
This document describes the functions and data in the
package and how to use them with \maximalink, assuming that you
do not know much about \maximalink, but do know quantum
information theory. However, most of the examples are also
found in introductory texts on quantum information.  The
package is intended for research and teaching in the theory
of entanglement and quantum information and related fields.


Examples of the facilities of the
package are
\begin{itemize}
%  \begin{item}
  \item    Methods for constructing pure and mixed states and operators.
%  \end{item}
%  \begin{item}
   \item  Methods for executing standard operations found in
    computational linear algebra as well as the tensor
    product, partial trace, etc.
%  \end{item}
%  \begin{item}
   \item Functions to compute commonly appearing quantities such as entropy and purity.
%  \end{item}
\end{itemize}

This document begins with a very brief introduction to
\maximalink emphasizing features that are important for
\qinfp. The remainder of the manual is a series of small
sections introducing functions with examples. The examples
mostly consist of testing equations. First identities and
textbook exercises are presented, in part because they are
the natural calculations to include in the test suite from
which they are taken. Then more complicated calculations are
tested, as that is the initial application of the author--- to
check manual calculations and results found in other documents.
In this restricted sense, the package can give results on
simple abstract statements: If 1) generic instances of objects are
generated, and 2) a representation-invariant statement is
formulated, and 3) the subexpressions are successfully coerced
into some canonical form, then defects in the statement can
sometimes be detected if the statement is not true.

Some suggestions and things to be aware of in the following sections.
\begin{itemize}
\item You probably need to read at least a ten minute
  \pname{Maxima} tutorial before or in conjunction with
  reading this document. There are several listed at the
  \maximalink website, and others that a search engine can
  find. If you are too impatient there is a very brief
  introduction to \maximalink below. The best source for
  most questions is the \maxman{\pname{Maxima} manual}{maxima.html}.
\begin{comment}
  \begin{item}
    Functions and features that are part of the standard \maximalink distribution,
    rather than part of the quantum information
    package are marked, where not obvious, with the dagger superscript--- \maxcom.
  \end{item}
\end{comment}
   \item
    There are several user interfaces to \maximalink. All the
    examples here are generated using the 
    \htmladdnormallink{\pname{imaxima}}{http://members3.jcom.home.ne.jp/imaxima/Site/Welcome.html}
    \iit{imaxima} package
    for the \ipname{emacs} editor/environment, but the results are
    similar to other graphical frontends to \maximalink. Other popular graphical
    frontends are \hlink{\pname{wxmaxima}}{http://wxmaxima.sourceforge.net}\iit{wxmaxima},
    and \hlink{\pname{texmacs}}{http://www.texmacs.org/}.\iit{texmacs}
   \item
    Most functions currently work only with qubits, others for variable number of
    states.
\end{itemize}

\subsection{Acknowledgments}

Some of the ideas used in \pname{qinf} are inspired by the package 
\html{\htmladdnormallink{\ipname{qdensity}}{http://www.pitt.edu/~tabakin/QDENSITY/}}
\begin{latexonly}
\ipname{qdensity} at \url{http://www.pitt.edu/~tabakin/QDENSITY/}
\end{latexonly}
written for a proprietary symbolic algebra system. None of
the code in qdensity has been borrowed for this project,
however. Advice on \pname{Maxima} and \pname{lisp}
programming was provided by, among others, Robert Dodier,
Stavros Macrakis, and Barton Willis.

\htmlrule

\section{Using \pname{Maxima}. features important for \qinf}
The package is loaded \index{loading \qinf}
using the \maxman{load}{\maximaload}\maxcom function like this
\bbm\index{\ifs{load}}
\begin{verbatim}
(%i1) load("qinf.mac");
\end{verbatim}
\begin{dmath}[number={\%o1}]
 \verb|qinf.mac|\end{dmath}
\ebm


There are several tutorials and manuals available for
\pname{Maxima}. Here is a very brief one focused on aiding the
introduction to the \qinf package.  We will not give examples
of matrices until later, but point out that the notation for
\index{matrix!multiplication} matrix multiplication in
\pname{Maxima} is a \maxman{dot}{maxima_25.html#SEC83}\index{dot product},
 eg. \verb|A . B|.  If
$A$ is a $m\times n$ and $B$ a $p\times q$ matrix, then the
result is a $n\times p$ matrix.  The inner
product\index{inner product} of quantum state vectors, the
outer product \index{outer product} (dyad\index{dyad})
 of quantum state vectors, the composition of
operators, and the mapping of one vector to another by an
operator are all special cases of matrix multiplication and
are all represented by the dot (along with conjugation in the case
 of the inner and outer products.)  The remaining product, the
tensor product\index{tensor product}, becomes the 
Kronecker product in the matrix
representation of a finite dimensional Hilbert space. To
agree with standard terminology, we introduce the
%\maxman{infix}{maxima_6.html#IDX156}
\maxman{infix}{\maximainfix}
operator \ifs{otimes} and the function \ifs{tensor\_product}
that eventually call the \pname{Maxima} function
\ifs{kronecker\_product}.  See the 
\maxman{section on matrices}{maxima_25.html#SEC81} in the \pname{Maxima}
manual.

\pname{Maxima} can use exact real and 
\maxman{complex numbers}{maxima_6.html#SEC22} or the
standard 
\maxman{floating point}{maxima_10.html#SEC38}  approximations, or 
\maxman{arbitrary precision floating point}{maxima_10.html#IDX367}
 numbers.  Numerical expressions are
\maxman{simplified}{maxima_7.html#SEC29} upon entry. Each input line must be terminated by
a semicolon (some interfaces do this automatically) or by a
dollar sign, which suppresses the output.
\bbm
\begin{verbatim}
(%i1) 1 + 1;
\end{verbatim}
\begin{dmath}[number={\%o1}]
  2\end{dmath} 
\ebm
\maxman{Assignment}{maxima_5.html#IDX71} is denoted by a colon \index{assignment} while
\maxman{function definitions}{maxima_5.html#IDX74} are denoted by 
%\verb|:=|  broken by some package cant remember.
:=
\index{functions!user defined}
For example, \verb| a : b+c ;| evaluates \verb|b+c| and assigns the result to \verb|a|.
On the other hand \verb| a(x,y) := x^y ;| defines the function $a(x,y)$.
\bbm
\begin{verbatim}
(%i2) a : 2 * 2;
\end{verbatim}
\begin{dmath}[number={\%o2}]
 4\end{dmath}
\begin{verbatim}
(%i3) a;
\end{verbatim}
\begin{dmath}[number={\%o3}]
 4\end{dmath}
\begin{verbatim}
(%i4) b : expand( (x+y)^4 );
\end{verbatim}
\begin{dmath}[number={\%o4}]
 y^{4}+4\*x\*y^{3}+6\*x^{2}\*y^{2}+4\*x^{3}\*y+x^{4}\end{dmath}
\ebm
\index{suppressing output}
We suppress the output here with a dollar sign because it's big-- $51$ terms.
\ibd{expand}
\bbm
\begin{verbatim}
(%i5) b : expand( (x+y)^50 )$
(%i6) length(b);
\end{verbatim}
\begin{dmath}[number={\%o6}]
 51\end{dmath}
\ebm
Some exact numbers and  \maxman{floating point}{maxima_10.html#SEC38} approximations.
\bbm
\begin{verbatim}
(%i7)  1  + sqrt(2);
\end{verbatim}
\begin{dmath}[number={\%o7}]
 \isqrt{2}+1\end{dmath}
\begin{verbatim}
index{floating point, conversion to}
(%i8)  1  + sqrt(2), float;
\end{verbatim}
\begin{dmath}[number={\%o8}]
 2.4142135623730949\end{dmath}
\ebm
\maxman{Defining}{maxima_39.html#SEC160} and using a function.
\index{functions!user defined}
\bbm
\begin{verbatim}
(%i9) f(x) := 3 * cos(x);
\end{verbatim}
\begin{dmath}[number={\%o9}]
 f\left(x\right):=3\*\cos x\end{dmath}
\begin{verbatim}
(%i10) f(a);
\end{verbatim}
\begin{dmath}[number={\%o10}]
 3\*\cos 4\end{dmath}
\begin{verbatim}
(%i11) f(0);
\end{verbatim}
\begin{dmath}[number={\%o11}]
 3\end{dmath}
\ebm
\index{complex numbers}
\maxman{Complex numbers}{maxima_6.html#SEC22}.
% \verb|%i|
\%i
 is the identifier for 
\index{imaginary unit $i$} $i=\sqrt{-1}$.
\bbm
\begin{verbatim}
(%i12) expand ( (1 + 2 * %i)^2 );
\end{verbatim}
\begin{dmath}[number={\%o12}]
 4\*i-3\end{dmath}
\ebm
Some special numbers are defined, such as 
%\verb|%pi|
\%pi
 \index{pi $\pi$}
and \index{$e$ base of natural log}
% \verb|%e|.
\%e.
\bbm
\begin{verbatim}
(%i13) cos(%pi/2);
\end{verbatim}
\begin{dmath}[number={\%o13}]
 0\end{dmath}
\begin{verbatim}
(%i14) %e^(%i * %pi/2);
\end{verbatim}
\begin{dmath}[number={\%o14}]
 i\end{dmath}
\ebm

\htmlrule
\section{Representation of states and operators}
Kets are represented by $n \times 1$ matrices, bras by $1
\times n$ matrices.\index{kets!representation} The objects
are represented in the computational basis.  Bras and kets
representing the same states are related by \pname{Maxima}'s conjugate
transpose \index{conjugate transpose}
\index{hermitian conjugate}
 function \maxman{\ifs{ctranspose}}{\maximactranspose}\maxcom.
Density operators and other operators
are represented by matrices.  The tensor product \index{tensor product!matrix representation}
is represented by the Kronecker product.  There is no strong
typing. You are responsible for knowing that a particular
vector represents a state vector in a particular space.
Below, we often substitute ``the operator'' for
``the matrix representing the operator''.
% That is, there is no facility to 
%distinguish between a vector in the product space of 
%two qubits ${\cal H}_1 \otimes {\cal H}_2 $ and the space of
%a single four state qudit.

\htmlrule
\section{Creating instances of states}
Here are some methods for creating instances of states, from scratch or
from other states. Although all operators  `create' states in this
sense, we omit most of them here, because they are better described as manipulating
states.
%\subsection{\func{ketz}{i_1,\ldots,i_n}, \func{braz}{i_1,\ldots,i_n},
%\func{ketx}{.}, \func{brax}{.},
%  \func{kety}{.}, \func{bray}{.}, multipartite eigenstates of 
%  $\sigma_x,\sigma_y,\sigma_z$}
\subsection{\ifs{ketz}, \ifs{braz},\ifs{ketx}, \ifs{brax},
  \ifs{kety}, \ifs{bray} --- multipartite eigenstates of  $\sigma_x,\sigma_y,\sigma_z$}
  \index{states!creating a ket}
\index{kets!creating a ket|see{states}}
create normalized $n$-partite states in the computational basis.
%\func{ketz}{i_1,\ldots,i_n} creates an eigenstate (ket) of $\sigma_z^{\otimes n}$
In all cases the indices are $0$ or $1$. The pair 
\func{ketz}{{i_1,\ldots,i_n}} and \func{braz}{{i_1,\ldots,i_n}} produce
eigenstates of $\sigma_z^{(1)} \otimes \cdots \otimes \sigma_z^{(n)}$,
with the index $i=0$ selecting the state with eigenvalue $1$ and
$i=1$ selecting the state with eigenvalue $-1$.
In other words the ket produced represents $\ket{i_1,i_2,\ldots,i_n}.$
\bbm
\begin{verbatim}
(%i3) ketz(1)
\end{verbatim}
\begin{dmath}[number={\%o3}]
 \pmatrix{0\cr 1\cr }\end{dmath}
\ebm
\bbm
\begin{verbatim}
(%i4) braz(1)
\end{verbatim}
\begin{dmath}[number={\%o4}]
 \pmatrix{0&\linebreak[0]1\cr }\end{dmath}
\ebm
\bbm
\begin{verbatim}
(%i5) braz(0)
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \pmatrix{1&\linebreak[0]0\cr }\end{dmath}
\ebm
\bbm
\begin{verbatim}
(%i6) braz(0,0)
\end{verbatim}
\begin{dmath}[number={\%o6}]
 \pmatrix{1&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr }\end{dmath}
\begin{verbatim}
(%i7) braz(1,1)
\end{verbatim}
\begin{dmath}[number={\%o7}]
 \pmatrix{0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]1\cr }\end{dmath}
\begin{verbatim}
(%i8) alpha[1]*braz(1,1)+alpha[0]*braz(0,0)
\end{verbatim}
\begin{dmath}[number={\%o8}]
 \pmatrix{\alpha_{0}&\linebreak[0]0&\linebreak[0]0&\linebreak[0]\alpha_{1}\cr }\end{dmath}
\ebm

The functions \ifs{ketx}, \ifs{brax}, \ifs{kety}, \ifs{bray} produce
eigenstates of $\sigma_x^{(1)} \otimes \cdots \otimes \sigma_x^{(n)}$,
or $\sigma_y^{(1)} \otimes \cdots \otimes \sigma_y^{(n)}$,
with, as before, the index $i=0$ selecting the state with eigenvalue $1$ and
$i=1$ selecting the state with eigenvalue $-1$.
\bbm
\begin{verbatim}
(%i9) brax(1)
\end{verbatim}
\begin{dmath}[number={\%o9}]
 \pmatrix{\ifracd{1}{\isqrt{2}}&\linebreak[0]-\ifracd{1}{\isqrt{2}}\cr }\end{dmath}
\begin{verbatim}
(%i10) bray(1,0,1)
\end{verbatim}
\begin{dmath}[number={\%o10}]
 \pmatrix{\ifracd{1}{2\*\isqrt{2}}&\linebreak[0]\ifracd{i}{2\*\isqrt{2}}&\linebreak[0]-\ifracd{i}{2\*\isqrt{2}}&\linebreak[0]\ifracd{1}{2\*\isqrt{2}}&\linebreak[0]\ifracd{i}{2\*\isqrt{2}}&\linebreak[0]-\ifracd{1}{2\*\isqrt{2}}&\linebreak[0]\ifracd{1}{2\*\isqrt{2}}&\linebreak[0]\ifracd{i}{2\*\isqrt{2}}\cr }\end{dmath}
\ebm

\subsection{\ifs{ket\_n}, \ifs{bra\_n} ---  alternate form of \ifs{ketz}, etc.}
\func{ket\_n}{j,i_1,\ldots,i_m} and \func{bra\_n}{j,i_1,\ldots,i_m}
 are an alternate way to call \fs{ketx}, \fs{kety}, etc. The index $j\in(1,2,3)$
is mapped to $(x,y,z)$ and the appropriate function, eg. \fs{ketx} is called with
the remaining arguments.

\subsection{\ifs{proj} --- Density matrix representation of a pure state (projection operator)}
The projection operator \index{projection operator}
\index{density operator!of a pure state} (or equivalently, the density
matrix) corresponding to a state vector is generated via the
outer product, which is represented by the dot operator.  A
convenience function \func{proj}{ket} is also provided to
form a projection operator. The argument \farg{ket} can be either a bra
or a ket (ie column or row vector). (\ifs{proj} does not check that
\farg{ket} is normalized.) Below, we use the \pname{Maxima} function
\ifs{ctranspose} for the complex transpose.
Here is the outer product, or dyad\index{outer product!of state vectors}\index{dyad}
$\ket{0}\bra{0}$.
\bbm
\begin{verbatim}
(%i19) ketx(1) . brax(1);
\end{verbatim}
\begin{dmath}[number={\%o19}]
 \pmatrix{\frac{1}{2}&\linebreak[0]-\frac{1}{2}\cr -\frac{1}{2}&\linebreak[0]\frac{1}{2}\cr }\end{dmath}
\ebm
Compare this to the inner product\index{inner product!of state vectors}
\bbm
\begin{verbatim}
(%i20) brax(1) . ketx(1);
\end{verbatim}
\begin{dmath}[number={\%o20}]
 1\end{dmath}
\ebm
Here are different ways to make $\ket{000}\bra{000}$ and $\ket{101}\bra{101}$.
\bbm
\begin{verbatim}
(%i21) is ( ketz(0,0,0) . braz(0,0,0) =  ketz(0,0,0) . ctranspose(ketz(0,0,0)) );
\end{verbatim}
\begin{dmath}[number={\%o21}]
 \mathbf{true}\end{dmath}
\begin{verbatim}
(%i22) is ( ketz(1,0,1) . braz(1,0,1) =  proj(ketz(1,0,1)) );
\end{verbatim}
\begin{dmath}[number={\%o22}]
 \mathbf{true}\end{dmath}
\ebm
This example used \pname{Maxima}'s 
\maxman{\func{is}{expr}}{\maximais}\maxcom\index{equality!testing for}
\ibd{is}  function which
tries to determine whether the predicate \farg{expr} is true or false.


There is also a function \ifs{tovect} that
is the inverse (up to a phase) of \ifs{proj}--- it returns the ket corresponding to a
projection operator. If the input matrix is not a projection operator,
the result is undefined.
\bbm
\begin{verbatim}
(%i17) is ( tovect( proj(schmidt_ket(alpha))) = schmidt_ket(alpha));
\end{verbatim}
\begin{dmath}[number={\%o17}]
 \mathbf{true}\end{dmath}
\ebm

\subsection{\ifs{otimes}, \ifs{tensor\_product}, \ifs{tensor\_power} \index{tensor product}
  \index{tensor power}
--- Creating state vectors with the tensor product.}
The function \func{tensor\_product}{v_1,\ldots,v_n}, returns
$v_1\otimes v_2\cdots\otimes v_n$, where $v_i$ are vectors
or matrices. The \fs{otimes} operator is an `infix' operator
that is equivalent to the function \fs{tensor\_product}.
The function \func{tensor\_power}{op,n}, returns the $n$th
tensor power of the operator \verb|op|. 
Once again, we will employ the 
% here, we have to make a separate bold index entry with \ibd, otherwise the link is broken
\maxman{\fs{is}\maxcom}{\maximais}\ibd{is}
 function.
Keep in mind that, in this example, the expressions are not
analyzed abstractly, but rather vectors with integer
elements are generated and compared elementwise.  \bbm
\begin{verbatim}
(%i12) is (ketz(0,1) = ketz(0) otimes ketz(1))
\end{verbatim}
\begin{dmath}[number={\%o12}]
 \mathbf{true}\end{dmath}
\begin{verbatim}
(%i13) is (ketz(0,1) = tensor_product(ketz(0),ketz(1)))
\end{verbatim}
\begin{dmath}[number={\%o13}]
 \mathbf{true}\end{dmath}
\begin{verbatim}
(%i14) is (ketx(0,1,0) otimes kety(1,0,1)
            = tensor_product(ketx(0),ketx(1),ketx(0),kety(1),kety(0),kety(1)))
\end{verbatim}
\begin{dmath}[number={\%o14}]
 \mathbf{true}\end{dmath}
\ebm

\subsection{\ifs{schmidt\_ket} --- bipartite state in Schmidt basis}
\func{schmidt\_ket}{a}creates a ket in the schmidt form. \index{Schmidt basis} This is
equivalent to \verb|sqrt(a)*ket(0,0)+ sqrt(1-a)*ket(1,1)|. This
only works for qubits ($d=2$). Note that you may need to
enter \verb|assume(a>0,1-a>0)|\ibd{assume} when manipulating this state
The \maxman{\fs{assume}}{\maximaassume}\maxcom command is used to build
a database of facts used, for instance, by the \ifs{is} command.

\subsection{\ifs{bell} and  \ifs{belln} --- Bell vectors in computational basis }
\index{Bell states}
create vector bell states. \fs{bell[a,b]} creates the state
\begin{equation}
 \ket{\Psi_{a,b}} = \frac{1}{\sqrt{2}} \ket{0,b} + (-1)^a  \ket{1,\bar b},
\end{equation}
where $a,b\in\{0,1\}$. The array \fs{belln[i]} creates the same states
where $i$ is the decimal representation of the binary numeration
$(a,b)$. That is, $(0,1,2,3)$ corresponds to $( (0,0), (0,1), (1,0), (1,1) )$.
Note that \fs{belln[i]} is a \pname{Maxima} array as indicated by the square
brackets.

As an exercise, we will check our definitions of the Bell
states by testing for orthonormality. \index{orthonormality!of Bell states} We first define an array
function \index{arrays!array functions} that returns the inner product of two Bell states.
An array function \fs{f[x,y]} is like an ordinary function
\fs{f(x,y)} except that it can be used where an array is
expected.
\bbm
\begin{verbatim}
(%i2) f[x,y] := belln[x] . belln[y];
\end{verbatim}
\begin{dmath}[number={\%o2}]
 f_{x,\linebreak[0]y}:=\mathrm{belln}_{x}\cdot \mathrm{belln}_{y}\end{dmath}
\ebm
Create a $4 \times 4$ matrix with \maxman{\fs{genmatrix}}{\maximagenmatrix}\maxcom\ibd{genmatrix}
 which maps the two dimension array \fs{f} over the indices of the matrix with the given range.
\bbm
\begin{verbatim}
(%i3) genmatrix( f , 3,3,0,0);
\end{verbatim}
\begin{dmath}[number={\%o3}]
  \pmatrix{1&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr
    0&\linebreak[0]1&\linebreak[0]0&\linebreak[0]0\cr
    0&\linebreak[0]0&\linebreak[0]1&\linebreak[0]0\cr
    0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]1\cr
  }\end{dmath}
\ebm
But instead of the named function \fs{f} we could have used
just a function body with the 
\maxman{\fs{lambda}}{\maximalambda}\maxcom \ibd{lambda} function,
which returns a function that is not bound to a symbol.
\bbm
\begin{verbatim}
(%i4) genmatrix( lambda( [x,y], belln[x] . belln[y]) , 3,3,0,0);
\end{verbatim}
\begin{dmath}[number={\%o4}]
 \pmatrix{1&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr 0&\linebreak[0]1&\linebreak[0]0&\linebreak[0]0\cr 0&\linebreak[0]0&\linebreak[0]1&\linebreak[0]0\cr 0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]1\cr }\end{dmath}
\ebm
It is obviously the $4 \times 4$ identity matrix.  The
function \ifunc{identitymatrixp}{mat} \index{identity matrix!testing for}
 is a predicate defined in the
quantum information package in analogy to the \pname{Maxima}
function \ifs{zeromatrixp}.  It returns \fs{true} only if its
argument is an identity matrix. (The symbol 
%\verb|%| 
\%
refers to the previous output.
\bbm
\begin{verbatim}
(%i5) identitymatrixp(%);
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \mathbf{true}\end{dmath}
\ebm
In the following sections, we often perform these comparisons in a single line. This
is how the test appears in the regression test suite.
\bbm
\begin{verbatim}
(%i6) identitymatrixp(genmatrix( lambda( [x,y], belln[x] . belln[y]) , 3,3,0,0));
\end{verbatim}
\begin{dmath}[number={\%o6}]
 \mathbf{true}\end{dmath}
\ebm
We see that these four vectors are orthonormal and thus form a basis in $\mathbb{C}^2\otimes \mathbb{C}^2$.
We can also check that
\begin{equation}
 \ket{\Psi_{00}}\bra{\Psi_{00}} +  \ket{\Psi_{01}}\bra{\Psi_{01}}
  + \ket{\Psi_{10}}\bra{\Psi_{10}} + \ket{\Psi_{11}}\bra{\Psi_{11}} = \mathbb{1}_4.
\end{equation}
\bbm
\begin{verbatim}
(%i2) identitymatrixp(apply("+",map(lambda([i],proj(belln[i])),[0,1,2,3])));
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \mathbf{true}\end{dmath}
\ebm

\subsection{\ifs{ghz} and  \ifs{ghzn} --- GHZ vectors}
The array \marray{ghz}{i,j,k} contains the GHZ kets defined by
\begin{equation}
 \ket{\Psi_{\mbox{GHZ}}(a,b,c)} 
 = \frac{1}{\sqrt{2}} \ket{0,b,c} + (-1)^a  \ket{1,\bar b,\bar c},
\end{equation}
where the bar denotes the logical not operation.
The array \marray{ghzn}{n} is the same array indexed by a single
decimal number equivalent to the binary numeration given by $a,b,c$.

\subsection{\ifs{werner} --- Werner state}
The Werner state is defined by 
$$
 \ket{\Psi(\lambda,i,j)}_{\mbox{Werner}} =
  \lambda \ket{\Psi(i,j)}_{\mbox{Bell}}\bra{\Psi(i,j)}_{\mbox{Bell}}
   + (1-\lambda) \rho_u,
$$
where $\rho_u=\mathbb{1}_4/4$. The \pname{qinf} function
is \verb|werner(a,i,j)|.
 The entropy \index{entropy!of Werner state} depends on neither $i$ nor $j$ and varies with $\lambda$ between
a value of $0$ and $1$ per bit, as the state is tuned from a pure state to 
the uniform mixed state.
\bbm
\begin{verbatim}
(%i2) wxplot2d(entropy(werner(a,1,0)), [a,0,1]);
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \includegraphics[width=.5\linewidth]{figs/werner_entropy}
\end{dmath}
\ebm

\htmlrule
\section{Creating and using operators}
\subsection{\ifs{pauli} --- pauli matrices}
\marray{pauli}{i}
creates the pauli matrices $(\sigma_0,\sigma_1,\sigma_2,\sigma_3)
=(\mathbb{1}_2,\sigma_x,\sigma_y,\sigma_z).$
\bbm
\begin{verbatim}
(%i12) [ pauli[0], pauli[1], pauli[2], pauli[3] ];
\end{verbatim}
\begin{dmath}[number={\%o12}]
 \left[ \pmatrix{1&\linebreak[0]0\cr 0&\linebreak[0]1\cr },\linebreak[0]\pmatrix{0&\linebreak[0]1\cr 1&\linebreak[0]0\cr },\linebreak[0]\pmatrix{0&\linebreak[0]-i\cr i&\linebreak[0]0\cr },\linebreak[0]\pmatrix{1&\linebreak[0]0\cr 0&\linebreak[0]-1\cr } \right] \end{dmath}
\ebm
Show that the ket $\ket{1}_x$ is an eigenvector of $\sigma_x$ with eigenvalue $-1$.
\bbm
\begin{verbatim}
(%i8) is (  pauli[1] . ket_n(1,1) = -1 * ket_n(1,1) );
\end{verbatim}
\begin{dmath}[number={\%o8}]
 \mathbf{true}\end{dmath}
\ebm
Here are we check that all our definitions of the pauli matrices and kets are
consistent in this sense.
\bbm
\begin{verbatim}
(%i9) mapapply( lambda([i,j], is (pauli[i] . ket_n(i,j) = (-1)^j * ket_n(i,j))),
         [[1,0],[1,1],[2,0],[2,1],[3,0],[3,1]  ]);
\end{verbatim}
\begin{dmath}[number={\%o9}]
 \left[ \mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true} \right] \end{dmath}
\ebm

Here we use \func{anticommutator}{op_1,op_2} \ibd{anticommutator} to test the anticommutation relations among
the pauli matrices: $\{\sigma_i,\sigma_j\}= 2\delta_{i,j}$ for $i,j \in\{1,2,3\}.$
\bbm
\ibd{genmatrix}
\begin{verbatim}
(%i3) genmatrix(lambda([i,j],  anticommutator(pauli[i],pauli[j])/2 ), 3,3,1,1);
\end{verbatim}
\begin{dmath}[number={\%o3}]
  \pmatrix{\pmatrix{1&\linebreak[0]0\cr 0&\linebreak[0]1\cr
    }&\linebreak[0]\pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr
    }&\linebreak[0]\pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr }\cr \pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr
    }&\linebreak[0]\pmatrix{1&\linebreak[0]0\cr
      0&\linebreak[0]1\cr
    }&\linebreak[0]\pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr }\cr \pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr
    }&\linebreak[0]\pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr
    }&\linebreak[0]\pmatrix{1&\linebreak[0]0\cr
      0&\linebreak[0]1\cr }\cr }\end{dmath}
\ebm 
The \pname{Maxima} function \ifs{mat\_unblocker}, flattens the
blocks in the above expression, so we can write \bbm
\begin{verbatim}
(%i4) identitymatrixp( mat_unblocker (genmatrix(lambda([i,j],  
         anticommutator(pauli[i],pauli[j])/2 ), 3,3,1,1)));
\end{verbatim}
\begin{dmath}[number={\%o4}]
  \mathbf{true}\end{dmath} \ebm Now we load the
\ifs{itensor} package, which provides the \index{levi-civita
  tensor} levi-civita tensor, and make use of the
\pname{Maxima} functions \ifs{permutations} (which returns
the \maxman{set}{\maximaSets} of all permutations of a list)
and \ifs{listify} (which converts the set data type into the (ordered) list data type).
The \qinf package provides \ibd{mapapply}
\func{mapapply}{func,[list1, list2,\ldots]}, which
\ifs{apply}s \farg{func} to each of the \farg{list}s and
returns a list of the results.  (see the \pname{Maxima}
documentation for \fs{apply}.)  With all these, we can test
the commutation relations \index{commutator} of the pauli
matrices. (In reality, the matrix definitions are not
complicated, we are actually testing the other functions.):
$[\sigma_i,\sigma_j] = 2i\epsilon_{i,j,k}\sigma_k$.  \bbm
\begin{verbatim}
(%i5) load("itensor");
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \verb|/usr/share/maxima/5.15.0/share/tensor/itensor.lisp|\end{dmath}
\begin{verbatim}
(%i6) mapapply(lambda([i,j,k],zeromatrixp(commutator(pauli[i],pauli[j]) 
     - 2*%i*levi_civita([i,j,k])*pauli[k])), listify(permutations([1,2,3])));
\end{verbatim}
\begin{dmath}[number={\%o6}]
 \left[ \mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true} \right] \end{dmath}
\ebm

\subsection{\ifs{pauli\_product} ---  tensor product of pauli matrices }
\func{pauli\_product}{i_1,\ldots,i_n} returns the tensor product
$\sigma_{i_1} \otimes \cdots \otimes \sigma_{i_n}$, where the indices
$i_j$ are in $\{0,1,2,3\}$. As elsewhere in this document, $\sigma_0$ is
the $2\times 2$ identity matrix.

\subsection{\ifs{insert\_operator} --- insert single qubit operators in $n$-qubit operator}
\func{insert\_operator}{nbits,[op1,i1,i2,..],[op2,j2,j2,...],...} returns
the operator $\mathbb{1}_2^{\otimes \mbox{nbits}}$, with some of the identity operators
$\mathbb{1}_2$ substituted by the operators \farg{op1,op2,\ldots} at the indices specified
by the indices $i1,i2,\ldots,j1,j2,\ldots$. Each replacement operator replaces a single
qubit identity operator $\mathbb{1}_2$, even if the replacement operator has dimension
other than $2$. 
 For example

\begin{center} 
\verb|insert_operator(8,[pauli[1],1,3],[pauli[2],2,5],[pauli[3],8])|
\end{center}
returns
$$
\sigma_x \otimes \sigma_y \otimes \sigma_x \otimes \mathbb{1}_2 
  \otimes \sigma_y \otimes  \mathbb{1}_2 \otimes  \mathbb{1}_2   \otimes \sigma_z.
$$
\fs{insert\_operator} is used to build the operators and gates listed below.

\subsection{\ient{Gates}}
\subsubsection{\ifs{hadamard}}
\pname{qinf} defines both a variable and a function named \fs{hadamard}.
The value of the  variable \fs{hadamard} is as follows,
\bbm
\begin{verbatim}
(%i2) hadamard;
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \pmatrix{\ifracd{1}{\isqrt{2}}&\linebreak[0]\ifracd{1}{\isqrt{2}}\cr \ifracd{1}{\isqrt{2}}&\linebreak[0]-\ifracd{1}{\isqrt{2}}\cr }\end{dmath}
\ebm
The function \func{hadamard}{nbits,i1,i2,\ldots}  returns the tensor product
of \farg{nbits} one-qubit operators each of which is $\mathbb{1}_2$ except
for the operators in positions \farg{i1,i2,\ldots} which are the hadamard
operator given by the variable \fs{hadamard}. The function is defined
by \verb|hadamard(nbits,[t]) := insert_operator(nbits,cons(hadamard,t))|,
which is an idiom that will work for similar user defined functions as well.
The dummy argument \verb|[t]| causes all arguments after \verb|nbits| to
be collected in a single list. The \pname{Maxima} function \func{cons}{expr,list}
returns the list given by  prepending 
 \verb|expr| to the list \verb|list|. 

\subsubsection{\ifs{controlled\_gate} --- gate with $n$ control qubits}
A controlled gate applies an operator $m$ to a single qubit (the target) in a register only if
each of a set of control qubits is set. Otherwise the operator is equivalent to
the identity operator. In any case, the operator is the identity on every
qubit other than the target.
The function \func{controlled\_gate}{nbits,qop,t,clst}
creates a controlled gate with one or more control qubits embedded in
a \verb|nbits|-qubit operator. The target qubit is at the index \verb|t|,
while the control qubits are at the indices listed in the list \verb|clst|.
In the returned operator, the $\mathbb{1}_2$ operator is at the remaining positions.
The controlled gate operator applies \verb|qop| at qubit \verb|t| if all of
the control qubits are set (ie are $1$) and is equivalent to the identity operator
otherwise.
For instance a \fs{cnot}\index{cnot} operator on $H_2\otimes H_2$ is given by
\verb|controlled_gate(2,pauli[1],2,[1])|.
The controlled gate in an $n$-qubit space with $n-1$ control bits and
the $1$-qubit target operator $m$ is implemented in \pname{qinf} as
$$
 \mathbb{1}_{2^n} + \left(\ket{1}\bra{1}\right)^{\otimes{n-1}}
    \otimes (m-\mathbb{1}_2).
$$
In the case that this  controlled gate operator is embedded in an operator in a larger space,
the same formula is used, with additional factors of $\mathbb{1}_2$ inserted at the 
appropriate places. Also the target qubit may occupy any index. This is implemented
via the \fs{insert\_operator} function described above.

\subsubsection{\ifs{cnot}, \ifs{cphase}, \ifs{crot}}
 \func{cnot}{nbits,t,c1,c2,\ldots} returns a cnot gate on an \verb|nbits|-qubit
register with the target at index \verb|t| and control qubits at indices
\verb|c1,c2,...|. The definition of this function is
\verb|cnot(nbits,t,[c]) := controlled_gate(nbits,pauli[1],t,c)|.
The functions \fs{cphase} and \fs{crot} are defined in the same way except
that operators \verb|pauli[3]| and  \verb|%i*pauli[2]| respectively are
substituted for \verb|pauli[1]|. For example, the elementary cnot gate
is given by \verb|cnot(2,2,1)|.
\subsubsection{\ifs{swap}}
\func{swap}{nbits,t1,t2} returns the operator that swaps qubits \verb|t1|
and \verb|t2| in an  \verb|nbits|-qubit register. It is defined by
\verb|swap(nbits,t1,t2) := cnot(nbits,t1,t2) . cnot(nbits,t2,t1) . cnot(nbits,t1,t2)|.
\subsubsection{\ifs{toffoli}}
This function is provided for convenience. It is defined by
\verb|toffoli(nbits,t,c1,c2) := cnot(nbits,t,c1,c2)|. Note that there
are exactly two control qubits.
\subsubsection{\ifs{fredkin}}
\func{fredkin}{nbits,t1,t2,c} is controlled swap operator. The qubits at indices
\verb|t1| and \verb|t2| are swapped if the control qubit at index \verb|c| is set.
\htmlrule
%\section{Entanglement-- \func{ptrace}{\rho,i_1,\ldots}, \func{entropy}{\rho}, \func{purity}{\rho}}
\section{Entanglement}

Now we are ready to introduce features that are more
specific to the study quantum entanglement, namely the
partial trace \fs{ptrace}, the von Neumann entropy
\fs{entropy} and \fs{purity}.


\subsection{\fs{ptrace}, \fs{ptracen} --- partial trace }
\index{trace!partial trace of matrix}
compute the partial trace of the  density 
operator $\rho$ over the component spaces given by the indices.
For \ifunc{ptrace}{\rho,i_1,\ldots} the density matrix $\rho$ is assumed to represent
an operator in
$(H_2)^{\otimes m}$, with $n=2$, that is
a tensor product of qubit spaces. For \ifunc{ptracen}{n,\rho,i_1,\ldots} the component
spaces are all $n$-state qudits.

In this example we create three arbitrary $3\times3$ matrices, and check that
$$
\mbox{Tr}_{1,2}\left(m_1\otimes m_2\otimes m_3\right) = \left(\mbox{Tr}(m_1)\mbox{Tr}(m_2)\right) m_3
$$
and that
$$
\mbox{Tr}_{3}\left(m_1\otimes m_2\otimes m_3 \right) = \mbox{Tr}(m_3)(m_1\otimes m_2).
$$
 Notice that we use the \pname{Maxima} function \ifs{ratsimp} to put both sides of the
equation in the same form because \ifs{=} checks only that two expressions are lexically
identical (well, modulo some details of the 
\maxman{simplification}{maxima_7.html#SEC29} process.) We also make
use of \pname{Maxima}'s \ifs{mat\_trace}\index{trace!of matrix} function ( so named to avoid conflicting
with the code-execution trace function) and \pname{Maxima}'s \ifs{matrix} command, which creates a matrix
from a list of rows. \index{matrix!trace} \index{matrix!creating}
\bbm
\begin{verbatim}
(%i1) m1 : matrix([a1,b1,c1],[d1,e1,f1],[g1,h1,i1])$

(%i2) m2 : matrix([a2,b2,c2],[d2,e2,f2],[g2,h2,i2])$

(%i3) m3 : matrix([a3,b3,c3],[d3,e3,f3],[g3,h3,i3])$

(%i4) is ( ratsimp( ptracen(3, m1 otimes m2 otimes m3 , 1,2) = 
            mat_trace(m1)*mat_trace(m2)*m3));
\end{verbatim}
\begin{dmath}[number={\%o4}]
 \mathbf{true}\end{dmath}
\begin{verbatim}
(%i5) is ( ratsimp( ptracen(3, m1 otimes m2 otimes m3 ,3) = mat_trace(m3)* m1 otimes m2));
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \mathbf{true}\end{dmath}
\ebm
Here we trace over one component repeatedly and check that the result is
equal to the full trace. Note that, each time, we are tracing over the new
first component.
\bbm
\begin{verbatim}
(%i10) factor( ptracen(3,ptracen(3,ptracen(3,m1 otimes m2 otimes m3,1),1),1));
\end{verbatim}
\begin{dmath}[number={\%o10}]
 \pmatrix{\left(\mathrm{i1}+\mathrm{e1}+\mathrm{a1}\right)\*\left(\mathrm{i2}+\mathrm{e2}+\mathrm{a2}\right)\*\left(\mathrm{i3}+\mathrm{e3}+\mathrm{a3}\right)\cr }\end{dmath}
\ebm

\subsection{\ifs{entropy} --- von Neumann entropy}
\index{entropy!von Neumann}
\func{entropy}{\rho} returns the von Neumann \fs{entropy} of
the density matrix $\rho$  defined by
\begin{equation}
 S(\rho) = -\mbox{Tr}\left(\rho \log_2 \rho\right).
\end{equation}
\ifs{entropyf} is the floating point version of \fs{entropy}.

\subsection{\ifs{renyi\_entropy}}
\index{entropy!R\'enyi}
 \func{renyi\_entropy}{alpha,rho} gives the R\'enyi entropy, defined by
\begin{equation}
 S_{\mbox{renyi}}(\alpha,\rho) = \frac{1}{1-\alpha}\log_2\left(\mbox{Tr}(\rho^\alpha)\right).
\end{equation}
\ifs{renyi\_entropyf} is the floating point version of \fs{renyi\_entropy}.

\subsection{\ifs{tsallis\_entropy}}
\index{entropy!Tsallis}
 \func{tsallis\_entropy}{q,rho} gives the Tsallis entropy, defined by
\begin{equation}
 S_{\mbox{tsallis}}(q,\rho) = \frac{1}{q-1}\left(1-\mbox{Tr}(\rho^q)\right).
\end{equation}
\ifs{tsallis\_entropyf} is the floating point version of \fs{tsallis\_entropy}.

\subsection{\ifs{purity}}
 \func{purity}{\rho} returns the purity of the 
density matrix $\rho$ defined by $\mbox{Tr}(\rho^2)$. The purity
is $1$ for a pure state and is less than $1$ for a mixed state.

\subsection{\ifs{fidelity}}
\func{fidelity}{\rho_1,\rho_2} returns the scalar valued fidelity
of the density matrices $\rho_1$ and $\rho_2$ defined by
$$
 \mbox{Tr}\left(\sqrt{\sqrt{\rho_2}\rho_1\sqrt{\rho_2}}\right).
$$

\subsection{An entangled pure global state has mixed reduced states}
We examine a textbook example of entanglement--- the joint
state of two qubits. The state of the whole system is pure,
but the local states are mixed.  We begin by creating a
joint state of two qubits in Schmidt basis
$\ket{\alpha}=\sqrt{\alpha}\ket{00}+
\sqrt{1-\alpha}\ket{11}.$ In order to see the mixed
character of the local states, we need to express the full
state as a density operator (or equivalently as a projection
operator.) Let's try to make $\ket{\alpha}\bra{\alpha}$.
\bbm
\begin{verbatim}
(%i2)  pr : proj(schmidt_ket(alpha));
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \pmatrix{\isqrt{\alpha}^{\star}\*\isqrt{\alpha}&\linebreak[0]0&\linebreak[0]0&\linebreak[0]\isqrt{1-\alpha}^{\star}\*\isqrt{\alpha}\cr 0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr 0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr \isqrt{\alpha}^{\star}\*\isqrt{1-\alpha}&\linebreak[0]0&\linebreak[0]0&\linebreak[0]\isqrt{1-\alpha}^{\star}\*\isqrt{1-\alpha}\cr }
\end{dmath}
\ebm
We see that \pname{Maxima} is allowing that the quantities under the radicals may be negative. So
we set some rules, and try again. \ibd{assume}
\bbm
\begin{verbatim}
(%i3) assume(alpha>0, 1-alpha>0);
\end{verbatim}
\begin{dmath}[number={\%o4}]
 \left[ \alpha>0,\linebreak[0]\alpha<1 \right] \end{dmath}
\begin{verbatim}
(%i5)  pr : proj(schmidt_ket(alpha));
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \pmatrix{\alpha&\linebreak[0]0&\linebreak[0]0&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{\alpha}\cr 0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr 0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr \isqrt{1-\alpha}\*\isqrt{\alpha}&\linebreak[0]0&\linebreak[0]0&\linebreak[0]1-\alpha\cr }\end{dmath}
\ebm
The entropy \index{entropy!of a pure state}
 vanishes for a pure state, so that $S(\ket{\alpha}\bra{\alpha})$ is
\bbm
\begin{verbatim}
(%i6)  entropy(pr);
\end{verbatim}
\begin{dmath}[number={\%o7}]
 0\end{dmath}
\ebm
The \ifs{purity} is equal to $1$ if and only if $\rho$ is a pure state.
\bbm
\begin{verbatim}
(%i8) purity(pr);
\end{verbatim}
\begin{dmath}[number={\%o8}]
 \alpha^{2}+2\*\left(1-\alpha\right)\*\alpha+\left(1-\alpha\right)^{2}\end{dmath}
The above line should be 
\maxman{simplified}{maxima_7.html#SEC29} by writing it as a canonical rational expression (CRE)
\ibd{ratsimp} \index{canonical rational expression}
\begin{verbatim}
(%i9) ratsimp(%);
\end{verbatim}
\begin{dmath}[number={\%o9}]
 1\end{dmath}
\ebm
Now we compute the reduced density matrix of the second qubit by tracing over the first---
$\rho_2=\mbox{Tr}_1 \ket{\alpha}\bra{\alpha}.$
\bbm
\begin{verbatim}
(%i10)  pr2 : ptrace(pr,1);
\end{verbatim}
\begin{dmath}[number={\%o10}]
 \pmatrix{\alpha&\linebreak[0]0\cr 0&\linebreak[0]1-\alpha\cr }\end{dmath}
\ebm
Tracing over the second qubit instead gives the same result
\bbm
\begin{verbatim}
(%i11) ptrace(pr,2);
\end{verbatim}
\begin{dmath}[number={\%o11}]
  \pmatrix{\alpha&\linebreak[0]0\cr
    0&\linebreak[0]1-\alpha\cr }\end{dmath} \ebm Computing
the entropy\index{entropy!of a reduced state} of a local state
shows that this state is, in general, mixed \bbm
\ibd{entropy}
\begin{verbatim}
(%i12) entropy(pr2);
\end{verbatim}
\begin{dmath}[number={\%o12}]
 -\alpha\*\mathrm{log2}\left(\alpha\right)-\mathrm{log2}\left(1-\alpha\right)\*\left(1-\alpha\right)\end{dmath}
\ebm
Each eigenvalue $\lambda$ satisfies $0\le \lambda <1$, so that the sum of their squares is less than
one 
\bbm
\begin{verbatim}
(%i13) purity(pr2);
\end{verbatim}
\begin{dmath}[number={\%o13}]
  \alpha^{2}+\left(1-\alpha\right)^{2}\end{dmath} \ebm We
can plot \index{plotting} the results (the plot command \ifs{plot2d} is more
common, depending on your user interface. \ifs{wxplot2d} has
the same calling syntax, but inlines the resulting plot.) We
see that the maximum entanglement occurs at $\alpha=1/2$ and
decreases monotonically from there in both directions, with
$\alpha=0,1$ giving pure joint states.  \bbm
\begin{verbatim}
(%i14)  wxplot2d([entropy(pr2), purity(pr2)],[alpha,0,1]);
\end{verbatim}
\begin{dmath}[number={\%o14}]
\includegraphics[width=.5\linewidth]{figs/entropy_purity}
\end{dmath}
\ebm

\htmlrule
\section{More operators and functions}

The next three functions 
\func{pauliexp}{\rho}, \func{invpauliexp}{c}, and \func{correlation\_tensor}{c,i_1,\ldots,i_n}
are related. An example using them follows their definitions.

\subsection{\ifs{pauliexp} --- expansion in terms of tensor products of pauli matrices  }
\func{pauliexp}{\rho} returns the correlation tensor,
\index{correlation tensor}
 that is, the coefficients in the expansion of the matrix $\rho$
in tensor products of pauli matrices. Explicitly, \fs{pauliexp}
returns the coefficients $c_{i_1,\ldots,i_n}$ in
\begin{equation}\label{pauliexp}
 \rho = \sum_{i_1,\ldots,i_n=0}^3 c_{i_1,\ldots,i_n} \ \sigma_{i_1} \otimes \cdots \otimes \sigma_{i_n}.
\end{equation}
$\rho$ must be a $2^n\times 2^n$ matrix. The coefficients are returned as a list
of $2^n\times 2^n$ elements. The place of $c_{i_1,\ldots,i_n}$ in the returned list is determined
by taking ${i_1,\ldots,i_n}$ to be the  binary representation of an integer. For convenience,
the coefficient can be retrieved by index with the function \fs{correlation\_tensor}.

\subsection{\ifs{invpauliexp} --- inverse of expansion in terms of tensor products of pauli matrices}
\func{invpauliexp}{c} is the inverse of \fs{pauiexp}. Given a list $c$ representing
the correlation tensor ({\it i.e.} expansion coefficients),
 \fs{invpauliexp} returns the matrix $\rho$ given by (\ref{pauliexp}).

\subsection{\fs{correlation\_tensor} --- retrieve component of correlation tensor by index}
\func{correlation\_tensor}{c,i_1,\ldots,i_n} returns the expansion coefficient for
the term $\sigma_{i_1} \otimes \cdots \otimes \sigma_{i_n}$ in the expansion of
$\rho$, where $c$ is the list of coefficients in the expansion of $\rho$ as given,
for instance, by \fs{pauliexp}.

\subsection{Using \fs{pauliexp} and \fs{invpauliexp}; an example}
Here is an example using the four functions defined above.
First we create three generic $2\times2$ (complex) matrices.
\bbm
\begin{verbatim}
(%i2) m1 : matrix([a1,b1],[c1,d1]);
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \pmatrix{\mathrm{a1}&\linebreak[0]\mathrm{b1}\cr \mathrm{c1}&\linebreak[0]\mathrm{d1}\cr }\end{dmath}
\begin{verbatim}
(%i3) m2 : matrix([a2,b2],[c2,d2]) $
(%i4) m3 : matrix([a3,b3],[c3,d3]) $
\end{verbatim}
\ebm
Here is the tensor product of the three matrices. This is {\it not} a generic element in
the three qubit Hilbert space represented by $M(\mathbb{C},8)$. For instance,
the three matrices have $12$ complex parameters while a generic matrix in
the tensor product space  has $64$ complex parameters.
\bbm
\begin{verbatim}
(%i5) mp : m1 otimes m2 otimes  m3 ;
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \pmatrix{\mathrm{a1}\*\mathrm{a2}\*\mathrm{a3}&\linebreak[0]\mathrm{a1}\*\mathrm{a2}\*\mathrm{b3}&\linebreak[0]\mathrm{a1}\*\mathrm{a3}\*\mathrm{b2}&\linebreak[0]\mathrm{a1}\*\mathrm{b2}\*\mathrm{b3}&\linebreak[0]\mathrm{a2}\*\mathrm{a3}\*\mathrm{b1}&\linebreak[0]\mathrm{a2}\*\mathrm{b1}\*\mathrm{b3}&\linebreak[0]\mathrm{a3}\*\mathrm{b1}\*\mathrm{b2}&\linebreak[0]\mathrm{b1}\*\mathrm{b2}\*\mathrm{b3}\cr \mathrm{a1}\*\mathrm{a2}\*\mathrm{c3}&\linebreak[0]\mathrm{a1}\*\mathrm{a2}\*\mathrm{d3}&\linebreak[0]\mathrm{a1}\*\mathrm{b2}\*\mathrm{c3}&\linebreak[0]\mathrm{a1}\*\mathrm{b2}\*\mathrm{d3}&\linebreak[0]\mathrm{a2}\*\mathrm{b1}\*\mathrm{c3}&\linebreak[0]\mathrm{a2}\*\mathrm{b1}\*\mathrm{d3}&\linebreak[0]\mathrm{b1}\*\mathrm{b2}\*\mathrm{c3}&\linebreak[0]\mathrm{b1}\*\mathrm{b2}\*\mathrm{d3}\cr \mathrm{a1}\*\mathrm{a3}\*\mathrm{c2}&\linebreak[0]\mathrm{a1}\*\mathrm{b3}\*\mathrm{c2}&\linebreak[0]\mathrm{a1}\*\mathrm{a3}\*\mathrm{d2}&\linebreak[0]\mathrm{a1}\*\mathrm{b3}\*\mathrm{d2}&\linebreak[0]\mathrm{a3}\*\mathrm{b1}\*\mathrm{c2}&\linebreak[0]\mathrm{b1}\*\mathrm{b3}\*\mathrm{c2}&\linebreak[0]\mathrm{a3}\*\mathrm{b1}\*\mathrm{d2}&\linebreak[0]\mathrm{b1}\*\mathrm{b3}\*\mathrm{d2}\cr \mathrm{a1}\*\mathrm{c2}\*\mathrm{c3}&\linebreak[0]\mathrm{a1}\*\mathrm{c2}\*\mathrm{d3}&\linebreak[0]\mathrm{a1}\*\mathrm{c3}\*\mathrm{d2}&\linebreak[0]\mathrm{a1}\*\mathrm{d2}\*\mathrm{d3}&\linebreak[0]\mathrm{b1}\*\mathrm{c2}\*\mathrm{c3}&\linebreak[0]\mathrm{b1}\*\mathrm{c2}\*\mathrm{d3}&\linebreak[0]\mathrm{b1}\*\mathrm{c3}\*\mathrm{d2}&\linebreak[0]\mathrm{b1}\*\mathrm{d2}\*\mathrm{d3}\cr \mathrm{a2}\*\mathrm{a3}\*\mathrm{c1}&\linebreak[0]\mathrm{a2}\*\mathrm{b3}\*\mathrm{c1}&\linebreak[0]\mathrm{a3}\*\mathrm{b2}\*\mathrm{c1}&\linebreak[0]\mathrm{b2}\*\mathrm{b3}\*\mathrm{c1}&\linebreak[0]\mathrm{a2}\*\mathrm{a3}\*\mathrm{d1}&\linebreak[0]\mathrm{a2}\*\mathrm{b3}\*\mathrm{d1}&\linebreak[0]\mathrm{a3}\*\mathrm{b2}\*\mathrm{d1}&\linebreak[0]\mathrm{b2}\*\mathrm{b3}\*\mathrm{d1}\cr \mathrm{a2}\*\mathrm{c1}\*\mathrm{c3}&\linebreak[0]\mathrm{a2}\*\mathrm{c1}\*\mathrm{d3}&\linebreak[0]\mathrm{b2}\*\mathrm{c1}\*\mathrm{c3}&\linebreak[0]\mathrm{b2}\*\mathrm{c1}\*\mathrm{d3}&\linebreak[0]\mathrm{a2}\*\mathrm{c3}\*\mathrm{d1}&\linebreak[0]\mathrm{a2}\*\mathrm{d1}\*\mathrm{d3}&\linebreak[0]\mathrm{b2}\*\mathrm{c3}\*\mathrm{d1}&\linebreak[0]\mathrm{b2}\*\mathrm{d1}\*\mathrm{d3}\cr \mathrm{a3}\*\mathrm{c1}\*\mathrm{c2}&\linebreak[0]\mathrm{b3}\*\mathrm{c1}\*\mathrm{c2}&\linebreak[0]\mathrm{a3}\*\mathrm{c1}\*\mathrm{d2}&\linebreak[0]\mathrm{b3}\*\mathrm{c1}\*\mathrm{d2}&\linebreak[0]\mathrm{a3}\*\mathrm{c2}\*\mathrm{d1}&\linebreak[0]\mathrm{b3}\*\mathrm{c2}\*\mathrm{d1}&\linebreak[0]\mathrm{a3}\*\mathrm{d1}\*\mathrm{d2}&\linebreak[0]\mathrm{b3}\*\mathrm{d1}\*\mathrm{d2}\cr \mathrm{c1}\*\mathrm{c2}\*\mathrm{c3}&\linebreak[0]\mathrm{c1}\*\mathrm{c2}\*\mathrm{d3}&\linebreak[0]\mathrm{c1}\*\mathrm{c3}\*\mathrm{d2}&\linebreak[0]\mathrm{c1}\*\mathrm{d2}\*\mathrm{d3}&\linebreak[0]\mathrm{c2}\*\mathrm{c3}\*\mathrm{d1}&\linebreak[0]\mathrm{c2}\*\mathrm{d1}\*\mathrm{d3}&\linebreak[0]\mathrm{c3}\*\mathrm{d1}\*\mathrm{d2}&\linebreak[0]\mathrm{d1}\*\mathrm{d2}\*\mathrm{d3}\cr }\end{dmath}
\ebm
We compute the correlation tensor of \verb|mp|
\bbm
\begin{verbatim}
(%i6) pe : pauliexp(mp) $
\end{verbatim}
\ebm
Check that the tensor has $64$ elements and see what a coefficient looks like.
\bbm
\begin{verbatim}
(%i7) length(pe);
\end{verbatim}
\begin{dmath}[number={\%o7}]
 64\end{dmath}
\begin{verbatim}
(%i8) part(pe,10);
\end{verbatim}
\begin{dmath}[number={\%o8}]
 \ifracn{-i\*\mathrm{c1}\*\mathrm{c2}\*\mathrm{d3}-i\*\mathrm{b1}\*\mathrm{c2}\*\mathrm{d3}+i\*\mathrm{b2}\*\mathrm{c1}\*\mathrm{d3}+i\*\mathrm{b1}\*\mathrm{b2}\*\mathrm{d3}-i\*\mathrm{a3}\*\mathrm{c1}\*\mathrm{c2}-i\*\mathrm{a3}\*\mathrm{b1}\*\mathrm{c2}+i\*\mathrm{a3}\*\mathrm{b2}\*\mathrm{c1}+i\*\mathrm{a3}\*\mathrm{b1}\*\mathrm{b2}}{8}\end{dmath}
\ebm
Check that the inverse of the expansion gives the original matrix back
\bbm
\begin{verbatim}
(%i9) is ( ratsimp( invpauliexp( pauliexp(mp) )) = mp);
\end{verbatim}
\begin{dmath}[number={\%o9}]
 \mathbf{true}\end{dmath}
\ebm
Here is the convenience function to return an element of the correlation tensor by index
\bbm
\begin{verbatim}
(%i10) correlation_tensor(pe,1,2,3);
\end{verbatim}
\begin{dmath}[number={\%o10}]
 \ifracn{i\*\mathrm{c1}\*\mathrm{c2}\*\mathrm{d3}+i\*\mathrm{b1}\*\mathrm{c2}\*\mathrm{d3}-i\*\mathrm{b2}\*\mathrm{c1}\*\mathrm{d3}-i\*\mathrm{b1}\*\mathrm{b2}\*\mathrm{d3}-i\*\mathrm{a3}\*\mathrm{c1}\*\mathrm{c2}-i\*\mathrm{a3}\*\mathrm{b1}\*\mathrm{c2}+i\*\mathrm{a3}\*\mathrm{b2}\*\mathrm{c1}+i\*\mathrm{a3}\*\mathrm{b1}\*\mathrm{b2}}{8}\end{dmath}
\ebm

\subsection{\ifs{spinor\_rotation}, \ifs{spinor\_rotation\_trig}}
\index{rotation!spinor}
\func{spinor\_rotation}{phi,theta,gamma} returns the matrix that represents
the operator that rotates a spinor through an angle \farg{gamma} about the axis specified by 
\farg{phi} (angle about the $z$-axis) and \farg{theta} (inclination from the $z$-axis). The function \func{spinor\_rotation\_trig}{phi,theta,gamma}
returns the same matrix expressed only with cosines and sines. This is the standard
axis-angle parameterization.  Explicitly the matrices are
\bbm
\begin{verbatim}
(%i2) spinor_rotation(phi,theta,gamma);
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \pmatrix{\cos \left(\frac{\gamma}{2}\right)-i\*\cos \vartheta\*\sin \left(\frac{\gamma}{2}\right)&\linebreak[0]-i\*\iexpt{e}{- i\*\varphi }\*\sin \vartheta\*\sin \left(\frac{\gamma}{2}\right)\cr -i\*\iexpt{e}{i\*\varphi}\*\sin \vartheta\*\sin \left(\frac{\gamma}{2}\right)&\linebreak[0]i\*\cos \vartheta\*\sin \left(\frac{\gamma}{2}\right)+\cos \left(\frac{\gamma}{2}\right)\cr }\end{dmath}
\begin{verbatim}
(%i3) spinor_rotation_trig(phi,theta,gamma);
\end{verbatim}
\begin{dmath}[number={\%o3}]
 \pmatrix{\cos \left(\frac{\gamma}{2}\right)-i\*\cos \vartheta\*\sin \left(\frac{\gamma}{2}\right)&\linebreak[0]\left(-\sin \varphi\*\sin \vartheta-i\*\cos \varphi\*\sin \vartheta\right)\*\sin \left(\frac{\gamma}{2}\right)\cr \left(\sin \varphi\*\sin \vartheta-i\*\cos \varphi\*\sin \vartheta\right)\*\sin \left(\frac{\gamma}{2}\right)&\linebreak[0]i\*\cos \vartheta\*\sin \left(\frac{\gamma}{2}\right)+\cos \left(\frac{\gamma}{2}\right)\cr }\end{dmath}.
\ebm

\htmlrule
\section{Entanglement.  longer examples}

\subsection{Entanglement swapping\index{entanglement swapping}}

In this subsection, we check a calculation that would
be relatively difficult to check by hand
Consider a pair of entangled qubits $A$ and $B$, and another
entangled pair $C$ and $D$. By performing a joint
measurement on, say $B$ and $C$, we can put $A$ and $B$ in
an entangled state although they may be widely separated.
We begin by considering the most general projective measure
on $B$ and $C$, and calculate the reduced density matrix for
a single qubit and the probability of outcome. In this
example we calculate these quantities two ways--- one,
directly from the density matrix formalism, and two, via
formulas taking advantage of the particulars of this
problem. To do the first calculation by hand would be
extremely unpleasant, as it involves multiplying $16\times16$
matrices with several factors in a single element. Carrying
it out below with \pname{Maxima} is a concise exercise.
 At present this example does not continue by discussing
the measurements that maximize the resulting entanglement
of $A$ and $D$.

Qubits $A$ and $B$ are in the state
$$
\ket{\alpha}=\sqrt{\alpha}\ket{00}+ \sqrt{1-\alpha}\ket{11},
$$
$C$ and $D$ are in the state
$$
\ket{\beta}=\sqrt{\beta}\ket{00}+ \sqrt{1-\beta}\ket{11},
$$
with the Schmidt coefficients \index{Schmidt coefficients}
satisfying $\alpha,\beta >1/2$.
For now, we only want to tell \pname{Maxima} that the coefficients
of the kets are real.\ibd{assume}
 \bbm
\begin{verbatim}
(%i2) assume(alpha>0,1-alpha>0,beta>0,1-beta>0);
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \left[ \alpha>0,\linebreak[0]\alpha<1,\linebreak[0]\beta>0,\linebreak[0]\beta<1 \right] \end{dmath}
\begin{verbatim}
(%i3) a : schmidt_ket(alpha);
\end{verbatim}
\begin{dmath}[number={\%o3}]
 \pmatrix{\isqrt{\alpha}\cr 0\cr 0\cr \isqrt{1-\alpha}\cr }\end{dmath}
\begin{verbatim}
(%i4) b : schmidt_ket(beta);
\end{verbatim}
\begin{dmath}[number={\%o4}]
 \pmatrix{\isqrt{\beta}\cr 0\cr 0\cr \isqrt{1-\beta}\cr }\end{dmath}
\ebm
We consider the projective measurement\index{projective measure} $\{E_m\}$, that is $E_m=\ket{u_m}\bra{u_m}$
and $\sum_m E_m=\mathbb{1}_4$. We consider only a single basis vector
here, so we don't use the subscript $m$ for \pname{Maxima} vector name.
We need to use \pname{Maxima}'s \ifs{declare} to declare that 
the components are complex. \index{complex numbers!declaring variable complex}
The state $\ket{u_m}$ is normalized, but we don't need to impose that condition in
\pname{Maxima} at this point.
\bbm
\begin{verbatim}
(%i5)  declare([u00,u01,u10,u11], complex);
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \mathbf{done}\end{dmath}
\begin{verbatim}
(%i6) u : ket(u00,u01,u10,u11);
\end{verbatim}
\begin{dmath}[number={\%o6}]
 \pmatrix{\mathrm{u00}\cr \mathrm{u01}\cr \mathrm{u10}\cr \mathrm{u11}\cr }\end{dmath}
\ebm
The initial joint state $\ket{\alpha\beta}\bra{\alpha\beta}$ is pure and remains
so after the measurement applying $\ket{u_m}\bra{u_m}$ to qubits $B$ and $C$.
But we write the density operator
because we will examine the reduced states, which are mixed.
In the case that $B$ and $C$ are projected onto $\ket{u_m}$, the state
of the entire system of four qubits after the measurement is given by
\begin{equation}
  \rho = \left( (\mathbb{1}_2 \otimes \ket{u_m}\bra{u_m} \otimes \mathbb{1}_2 )
     \ket{\alpha\beta}\bra{\alpha\beta}\right),   
\end{equation}
with
\bbm
\begin{verbatim}
(%i7) rho : conjsimp((ident(2) otimes proj(u) otimes ident(2)) . proj(a otimes b))$,
\end{verbatim}
\ebm
where \ifs{conjsimp} 
(supplied via the \pname{Maxima} listserv by Barton Willis) replaces $xx^*$ with $|x|^2$,
and $\ifunc{ident}{n}$ \index{identity matrix!creating} is the $n\times n$ identity matrix.
The output was suppressed with the trailing dollar sign because the $\rho$ is
a $16\times16$ matrix with large expressions for entries.
%\everymath{\scriptscriptstyle}
%\newcommand{\myrm}[1]{\scriptscriptstyle{#1}}
%\newcommand{\mylineb}{\scriptscriptstyle \linebreak[0] \scriptscriptstyle }
%\newcommand{\myalpha}{\scriptscriptstyle \alpha }
%\newcommand{\myisqrt}[1]{\scriptscriptstyle\sqrt{#1}}
The reduced state of qubits $A$ and $D$ is obtained by tracing out components $2$ and
$3$ corresponding to qubits $B$ and $C$, ie  $\rho_{AD} =\mbox{Tr}_{BC}\rho$.
\ibd{ptrace}
\bbm
\begin{verbatim}
(%i8) rho_14 : ptrace(rho,2,3);
\end{verbatim}
\begin{dmath}[number={\%o8},style={\tiny}]
 \pmatrix{\alpha\*\beta\*\left| \mathrm{u00}\right| ^{2}&\linebreak[0]\alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}^{\star}\*\mathrm{u01}&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{\alpha}\*\beta\*\mathrm{u00}^{\star}\*\mathrm{u10}&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{\alpha}\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}^{\star}\*\mathrm{u11}\cr \alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}\*\mathrm{u01}^{\star}&\linebreak[0]\left(\alpha-\alpha\*\beta\right)\*\left| \mathrm{u01}\right| ^{2}&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{\alpha}\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u01}^{\star}\*\mathrm{u10}&\linebreak[0]\left(\isqrt{1-\alpha}\*\isqrt{\alpha}-\isqrt{1-\alpha}\*\isqrt{\alpha}\*\beta\right)\*\mathrm{u01}^{\star}\*\mathrm{u11}\cr \isqrt{1-\alpha}\*\isqrt{\alpha}\*\beta\*\mathrm{u00}\*\mathrm{u10}^{\star}&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{\alpha}\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u01}\*\mathrm{u10}^{\star}&\linebreak[0]\left(1-\alpha\right)\*\beta\*\left| \mathrm{u10}\right| ^{2}&\linebreak[0]\left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}^{\star}\*\mathrm{u11}\cr \isqrt{1-\alpha}\*\isqrt{\alpha}\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}\*\mathrm{u11}^{\star}&\linebreak[0]\left(\isqrt{1-\alpha}\*\isqrt{\alpha}-\isqrt{1-\alpha}\*\isqrt{\alpha}\*\beta\right)\*\mathrm{u01}\*\mathrm{u11}^{\star}&\linebreak[0]\left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}\*\mathrm{u11}^{\star}&\linebreak[0]\left(\left(\alpha-1\right)\*\beta-\alpha+1\right)\*\left| \mathrm{u11}\right| ^{2}\cr }\end{dmath}
\ebm
Likewise, the reduced state of just qubit $D$ is
$\rho_{D} =\mbox{Tr}_{ABC}\rho$.\ibd{ptrace}\index{reduced state}
\bbm
\begin{verbatim}
(%i9) rho_4 : ptrace(rho,1,2,3);
\end{verbatim}
\begin{dmath}[number={\%o9}]
 \pmatrix{\left(1-\alpha\right)\*\beta\*\left| \mathrm{u10}\right| ^{2}+\alpha\*\beta\*\left| \mathrm{u00}\right| ^{2}&\linebreak[0]\left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}^{\star}\*\mathrm{u11}+\alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}^{\star}\*\mathrm{u01}\cr \left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}\*\mathrm{u11}^{\star}+\alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}\*\mathrm{u01}^{\star}&\linebreak[0]\left(\left(\alpha-1\right)\*\beta-\alpha+1\right)\*\left| \mathrm{u11}\right| ^{2}+\left(\alpha-\alpha\*\beta\right)\*\left| \mathrm{u01}\right| ^{2}\cr }\end{dmath}
\ebm
The second method of calculating $\rho_{D}$ is as follows.
Considering the following map from
$\mathbb{C}^2\otimes\mathbb{C}^2$ to $M(\mathbb{C},2)$:
\begin{equation}\label{ket_to_mat}
    \ket{a}=\sum_{i,j=0}^1 a_{ij}\ket{ij}\quad\mapsto\quad\widehat{a}=
    \pmatrix{
      a_{00} & a_{01} \cr
      a_{10} & a_{11} \cr
    },
\end{equation}
one can show that $\rho_{D}$ is equal to $X_m^{\dagger}X_m$, with
$X_m = \widehat{\alpha}\,\widehat{u}_m\,\widehat{\beta}$.
The \pname{Maxima} function implementing the mapping (\ref{ket_to_mat}) is
\bbm
\begin{verbatim}
(%i10) ket_to_mat(iket) := matrix([iket[1,1],iket[2,1]],[iket[3,1],iket[4,1]])$
\end{verbatim}
\ebm
Then the second calculation of $\rho_D$, which we call \verb|rho_4a| is given by
the following lines.
\bbm
\begin{verbatim}
(%i11) mu : ket_to_mat(u)$
(%i12) X :  ket_to_mat(a) . mu . ket_to_mat(b);
\end{verbatim}
\begin{dmath}[number={\%o12}]
 \pmatrix{\isqrt{\alpha}\*\isqrt{\beta}\*\mathrm{u00}&\linebreak[0]\isqrt{\alpha}\*\isqrt{1-\beta}\*\mathrm{u01}\cr \isqrt{1-\alpha}\*\isqrt{\beta}\*\mathrm{u10}&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{1-\beta}\*\mathrm{u11}\cr }\end{dmath}
\begin{verbatim}
(%i13) rho_4a : conjsimp( ctranspose(X) . X );
\end{verbatim}
\begin{dmath}[number={\%o13}]
 \pmatrix{\left(1-\alpha\right)\*\beta\*\left| \mathrm{u10}\right| ^{2}+\alpha\*\beta\*\left| \mathrm{u00}\right| ^{2}&\linebreak[0]\left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}^{\star}\*\mathrm{u11}+\alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}^{\star}\*\mathrm{u01}\cr \left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}\*\mathrm{u11}^{\star}+\alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}\*\mathrm{u01}^{\star}&\linebreak[0]\left(\left(\alpha-1\right)\*\beta-\alpha+1\right)\*\left| \mathrm{u11}\right| ^{2}+\left(\alpha-\alpha\*\beta\right)\*\left| \mathrm{u01}\right| ^{2}\cr }\end{dmath}
\ebm
We compare \verb|(%o9)| and  \verb|(%o13)|, to see that the two methods of calculating
the reduced state for qubit $D$ after the measurement give the same result
\bbm
\begin{verbatim}
(%i14) is ( ratsimp(rho_4a) = ratsimp(rho_4) );
\end{verbatim}
\begin{dmath}[number={\%o14}]
 \mathbf{true}\end{dmath}
\ebm
Now we compute the probability 
$p_m=\mbox{Tr}(\rho)=\mbox{Tr}(\rho_D)$
that the state is in fact projected onto $\ket{u_m}$.
\bbm
\begin{verbatim}
(%i15) P1 : conjsimp( mat_trace(rho));
\end{verbatim}
\begin{dmath}[number={\%o15}]
 \left(\left(\alpha-1\right)\*\beta-\alpha+1\right)\*\left| \mathrm{u11}\right| ^{2}+\left(1-\alpha\right)\*\beta\*\left| \mathrm{u10}\right| ^{2}+\left(\alpha-\alpha\*\beta\right)\*\left| \mathrm{u01}\right| ^{2}+\alpha\*\beta\*\left| \mathrm{u00}\right| ^{2}\end{dmath}
\ebm
Finally, we compare this to the trace computed by hand from the expression following (\ref{ket_to_mat}),
which is given by
\begin{equation}
 p_m=\sum^1_{i,j=0} {\alpha}_{i} {\beta}_{j} |\widehat{u}_{m,ij}|^2,
\end{equation}
where $\alpha_0=\alpha,\  \alpha_1=1-\alpha, \  \beta_0=\beta, \ \beta_1=1-\beta$,
\bbm
\begin{verbatim}
(%i16) av : [alpha,1-alpha]$
(%i17) bv : [beta,1-beta] $
(%i18) P2 : apply( "+", create_list( av[i] * abs(mu[i,j])^2 * bv[j], i,[1,2],j,[1,2]));
\end{verbatim}
\begin{dmath}[number={\%o18}]
 \left(1-\alpha\right)\*\left(1-\beta\right)\*\left| \mathrm{u11}\right| ^{2}+\left(1-\alpha\right)\*\beta\*\left| \mathrm{u10}\right| ^{2}+\alpha\*\left(1-\beta\right)\*\left| \mathrm{u01}\right| ^{2}+\alpha\*\beta\*\left| \mathrm{u00}\right| ^{2}\end{dmath}.
\ebm
Here we have used \pname{Maxima}'s \ifs{apply} and \ifs{create\_list} functions.
Once again we compare the probabilities computed via the two methods
\bbm
\begin{verbatim}
(%i19) is (ratsimp(P1) = ratsimp(P2));
\end{verbatim}
\begin{dmath}[number={\%o19}]
 \mathbf{true}\end{dmath}
\ebm
and see that they give the same result.

%\section*{Index}
\htmlrule
\newpage
\addcontentsline{toc}{section}{Index}
\printindex
\htmlrule

%\addcontentsline{toc}{section}{Index}

\end{document}
